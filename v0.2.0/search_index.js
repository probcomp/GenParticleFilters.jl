var documenterSearchIndex = {"docs":
[{"location":"resize/#Particle-Filter-Resizing","page":"Particle Filter Resizing","title":"Particle Filter Resizing","text":"","category":"section"},{"location":"resize/","page":"Particle Filter Resizing","title":"Particle Filter Resizing","text":"CurrentModule = GenParticleFilters","category":"page"},{"location":"resize/","page":"Particle Filter Resizing","title":"Particle Filter Resizing","text":"Some particle filtering algorithms may adaptively resize the number of particles in order to trade-off time and accuracy, or temporarily replicate existing particles in order to better explore the state space. GenParticleFilters.jl supports these algorithms by providing methods for resizing or replicating particles.","category":"page"},{"location":"resize/","page":"Particle Filter Resizing","title":"Particle Filter Resizing","text":"pf_resize!","category":"page"},{"location":"resize/#GenParticleFilters.pf_resize!","page":"Particle Filter Resizing","title":"GenParticleFilters.pf_resize!","text":"pf_resize!(state::ParticleFilterState, n_particles::Int,\n           method=:multinomial; kwargs...)\n\nResizes a particle filter by resampling existing particles until a total of  n_particles have been sampled. The resampling method can optionally be specified: :multinomial (default) or :residual.\n\nA priority_fn can also be specified as a keyword argument, which maps log particle weights to custom log priority scores for the purpose of resampling (e.g. w -> w/2 for less aggressive pruning).\n\n\n\n\n\n","category":"function"},{"location":"resize/#Resizing-via-multinomial-resampling","page":"Particle Filter Resizing","title":"Resizing via multinomial resampling","text":"","category":"section"},{"location":"resize/","page":"Particle Filter Resizing","title":"Particle Filter Resizing","text":"pf_multinomial_resize!","category":"page"},{"location":"resize/#GenParticleFilters.pf_multinomial_resize!","page":"Particle Filter Resizing","title":"GenParticleFilters.pf_multinomial_resize!","text":"pf_multinomial_resize!(state::ParticleFilterState, n_particles::Int;\n                       kwargs...)\n\nResizes a particle filter through multinomial resampling (i.e. simple random resampling) of existing particles until n_particles are sampled. Each trace (i.e. particle) is resampled with probability proportional to its weight.\n\nA priority_fn can be specified as a keyword argument, which maps log particle weights to custom log priority scores for the purpose of resampling (e.g. w -> w/2 for less aggressive pruning).\n\n\n\n\n\n","category":"function"},{"location":"resize/#Resizing-via-residual-resampling","page":"Particle Filter Resizing","title":"Resizing via residual resampling","text":"","category":"section"},{"location":"resize/","page":"Particle Filter Resizing","title":"Particle Filter Resizing","text":"pf_residual_resize!","category":"page"},{"location":"resize/#GenParticleFilters.pf_residual_resize!","page":"Particle Filter Resizing","title":"GenParticleFilters.pf_residual_resize!","text":"pf_residual_resize!(state::ParticleFilterState, n_particles::Int; kwargs...)\n\nResizes a particle filter through residual resampling of existing particles. For each particle with normalized weight w_i, n w_i copies are resampled, w here n is n_particles. The remainder are sampled with probability proportional to n w_i - n w_i for each particle i.\n\nA priority_fn can be specified as a keyword argument, which maps log particle weights to custom log priority scores for the purpose of resampling (e.g. w -> w/2 for less aggressive pruning).\n\n\n\n\n\n","category":"function"},{"location":"resize/#Particle-replication","page":"Particle Filter Resizing","title":"Particle replication","text":"","category":"section"},{"location":"resize/","page":"Particle Filter Resizing","title":"Particle Filter Resizing","text":"pf_replicate!","category":"page"},{"location":"resize/#GenParticleFilters.pf_replicate!","page":"Particle Filter Resizing","title":"GenParticleFilters.pf_replicate!","text":"pf_replicate!(state::ParticleFilterState, n_replicates::Int;\n              layout=:contiguous)\n\nExpands a particle filter by replicating each particle n_replicates times. \n\nIf layout is :contiguous, each particle's replicates will be arranged in a continguous block (e.g., replicates of the first particle will have indices 1:n_replicates).\n\nOtherwise, if layout is :interleaved, each particle's replicates will be interleaved with the replicates of the other particles (e.g., replicates of the first particle will have indices 1:n_replicates:N*n_replicates, where N is the original number of particles).\n\n\n\n\n\n","category":"function"},{"location":"resize/#Particle-dereplication","page":"Particle Filter Resizing","title":"Particle dereplication","text":"","category":"section"},{"location":"resize/","page":"Particle Filter Resizing","title":"Particle Filter Resizing","text":"pf_dereplicate!","category":"page"},{"location":"resize/#GenParticleFilters.pf_dereplicate!","page":"Particle Filter Resizing","title":"GenParticleFilters.pf_dereplicate!","text":"pf_dereplicate!(state::ParticleFilterState, n_replicates::Int;\n                layout=:contiguous, method=:keepfirst)\n\nShrinks a particle filter by retaining one out of every n_replicates particles. The total number of particles must be a multiple of n_replicates.\n\nIf layout is :contiguous, each set of replicates is assumed to be arranged in a contiguous block (e.g., the first particle will be selected out of the indices 1:n_replicates).\n\nOtherwise, if layout is :interleaved, each set of replicates is assumed to be interleaved with others (e.g., the first particle will be selected out of the indices 1:n_replicates:N, where N is the total number of particles).\n\nRetained particles can be selected by different methods. If method is :keepfirst, only the first particle of each set of replicates is retained, exactly reversing the effect of pf_replicate!. If method is  :sample, the retained particle is sampled according to its normalized weight among the replicates.\n\n\n\n\n\n","category":"function"},{"location":"translate/#Trace-Translators","page":"Trace Translators","title":"Trace Translators","text":"","category":"section"},{"location":"translate/","page":"Trace Translators","title":"Trace Translators","text":"CurrentModule = GenParticleFilters","category":"page"},{"location":"translate/","page":"Trace Translators","title":"Trace Translators","text":"GenParticleFilters.jl provides two additional types of trace translators for use in particle filtering and sequential Monte Carlo algorithms.","category":"page"},{"location":"translate/#Extending-Trace-Translator","page":"Trace Translators","title":"Extending Trace Translator","text":"","category":"section"},{"location":"translate/","page":"Trace Translators","title":"Trace Translators","text":"This trace translator can be used to sample new latent variables from a custom proposal, then optionally apply a deterministic transform to those latent variables before they are used to update the model trace.","category":"page"},{"location":"translate/","page":"Trace Translators","title":"Trace Translators","text":"ExtendingTraceTranslator\nExtendingTraceTranslator(::Trace)","category":"page"},{"location":"translate/#GenParticleFilters.ExtendingTraceTranslator","page":"Trace Translators","title":"GenParticleFilters.ExtendingTraceTranslator","text":"translator = ExtendingTraceTranslator(;\n    p_new_args::Tuple = (),\n    p_argdiffs::Tuple = (),\n    new_observations::ChoiceMap = EmptyChoiceMap(),\n    q_forward::GenerativeFunction,\n    q_forward_args::Tuple = (),\n    transform::Union{TraceTransformDSLProgram,Nothing} = nothing\n)\n\nConstructor for an extending trace translator, which extends a trace by  sampling new random choices from a forward proposal q_forward, optionally applying a trace transform to those choices, then updating the trace with the proposed (and transformed) choices, along with new_observations.\n\n\n\n\n\n","category":"type"},{"location":"translate/#GenParticleFilters.ExtendingTraceTranslator-Tuple{Gen.Trace}","page":"Trace Translators","title":"GenParticleFilters.ExtendingTraceTranslator","text":"(output_trace, log_weight) = translator(input_trace; check=true)\n\nRun an ExtendingTraceTranslator on an input trace, returning the output trace and the (incremental) importance weight.\n\nIf check is enabled, a check is performed to ensure that no choices are  discarded as a result of updating the trace. This is recommended by default, but can be disabled to allow trace updates that replace previously constrained observations with different values.\n\n\n\n\n\n","category":"method"},{"location":"translate/#Updating-Trace-Translator","page":"Trace Translators","title":"Updating Trace Translator","text":"","category":"section"},{"location":"translate/","page":"Trace Translators","title":"Trace Translators","text":"This trace translator supports forward and backward proposals (which may include auxiliary randomness), as well as deterministic transformations between proposed choices and model choices.","category":"page"},{"location":"translate/","page":"Trace Translators","title":"Trace Translators","text":"UpdatingTraceTranslator\nUpdatingTraceTranslator(::Trace)","category":"page"},{"location":"translate/#GenParticleFilters.UpdatingTraceTranslator","page":"Trace Translators","title":"GenParticleFilters.UpdatingTraceTranslator","text":"translator = UpdatingTraceTranslator(;\n    p_new_args::Tuple = (),\n    p_argdiffs::Tuple = (),\n    new_observations::ChoiceMap = EmptyChoiceMap(),\n    q_forward::GenerativeFunction,\n    q_forward_args::Tuple  = (),\n    q_backward::GenerativeFunction,\n    q_backward_args::Tuple  = (),\n    transform::Union{TraceTransformDSLProgram,Nothing} = nothing\n)\n\nConstructor for a updating trace translator, which updates the trace of model given a forward proposal q_forward, backward proposal q_backward, new arguments for that model p_new_args, and new_observations.\n\nOptionally, a trace transform can be provided, specifying how the input model trace and forward proposal trace get mapped to the output model trace and  backward proposal trace.\n\nWhen a transform is not provided, the update performed by an UpdatingTraceTranslator corresponds to Del Moral SMC [1]. When a transform is provided, the update corresponds to SMCP³ [2], a more general form of SMC that supports proposals with auxiliary randomness, as well as deterministic  transformations between random variables in the model and the proposals.\n\n[1] P. D. Moral, A. Doucet, and A. Jasra, \"Sequential Monte Carlo samplers,\" Journal of the Royal Statistical Society: Series B (Statistical Methodology), vol. 68, no. 3, pp. 411–436, 2006.\n\n[2] Lew, A. K., Matheos, G., Zhi-Xuan, T., Ghavamizadeh, M., Gothoskar, N., Russell, S., and Mansinghka, V. K. \"SMCP3: Sequential Monte Carlo with Probabilistic Program Proposals.\", AISTATS, 2023.\n\n\n\n\n\n","category":"type"},{"location":"translate/#GenParticleFilters.UpdatingTraceTranslator-Tuple{Gen.Trace}","page":"Trace Translators","title":"GenParticleFilters.UpdatingTraceTranslator","text":"(output_trace, log_weight) = translator(input_trace; kwargs...)\n\nRun an UpdatingTraceTranslator on an input trace, returning the output trace and the (incremental) importance weight.\n\nKeyword Arguments\n\nSet check = true to enable a bijection check (this requires that the transform has been paired with its inverse using pair_bijections! or is_involution!).\n\nIf check is enabled, then prev_observations should be provided as a choicemap containing the random choices in the input trace that are replaced by new_observations, or deleted due to a change in the arguments. Typically no observations are replaced or deleted, so prev_observations is an EmptyChoiceMap by default.\n\n\n\n\n\n","category":"method"},{"location":"update/#Particle-Updating","page":"Particle Updating","title":"Particle Updating","text":"","category":"section"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"CurrentModule = GenParticleFilters","category":"page"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"GenParticleFilters.jl provides numerous methods for updating particles with new observations or input arguments, ranging from simply conditioning on the new observations, to complex SMC moves that allow for the use of auxiliary randomness and deterministic transformations.","category":"page"},{"location":"update/#Updating-with-the-default-proposal","page":"Particle Updating","title":"Updating with the default proposal","text":"","category":"section"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"pf_update!(state::ParticleFilterView, new_args::Tuple,\n           argdiffs::Tuple, observations::ChoiceMap)","category":"page"},{"location":"update/#GenParticleFilters.pf_update!-Tuple{ParticleFilterView{U} where U, Tuple, Tuple, Gen.ChoiceMap}","page":"Particle Updating","title":"GenParticleFilters.pf_update!","text":"pf_update!(state::ParticleFilterState, new_args::Tuple,\n           argdiffs::Tuple, observations::ChoiceMap)\n\nPerform a particle filter update, where the model arguments are adjusted and new observations are conditioned upon. New latent choices are sampled from the model's default proposal.\n\n\n\n\n\n","category":"method"},{"location":"update/#Updating-with-a-custom-proposal","page":"Particle Updating","title":"Updating with a custom proposal","text":"","category":"section"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"pf_update!(\n    state::ParticleFilterView,\n    new_args::Tuple, argdiffs::Tuple,\n    observations::ChoiceMap,\n    proposal::GenerativeFunction, proposal_args::Tuple,\n    transform::Union{TraceTransformDSLProgram,Nothing}\n)","category":"page"},{"location":"update/#GenParticleFilters.pf_update!-Tuple{ParticleFilterView{U} where U, Tuple, Tuple, Gen.ChoiceMap, Gen.GenerativeFunction, Tuple, Union{Nothing, Gen.TraceTransformDSLProgram}}","page":"Particle Updating","title":"GenParticleFilters.pf_update!","text":"pf_update!(state::ParticleFilterState, new_args::Tuple,\n           argdiffs::Tuple, observations::ChoiceMap,\n           proposal::GenerativeFunction, proposal_args::Tuple,\n           [transform::TraceTransformDSLProgram];\n           check::Bool=true)\n\nPerform a particle filter update, where the model arguments are adjusted and new observations are conditioned upon. New latent choices are sampled from a custom proposal distribution in conjuction with the model's default proposal. For each particle:\n\nproposal is evaluated with arguments (t_old, proposal_args...),  where t_old is the old model trace, and produces its own trace t_prop.\nThe old model trace is replaced by a new model trace t_new, constructed by merging the choices in t_old and t_prop, and sampling any remaining choices from the model's default proposal.\n\nThe choicemap of t_new satisfies the following conditions:\n\nobservations is a subset of get_choices(t_new);\nget_choices(t_old) is a subset of get_choices(t_new);\nget_choices(t_prop) is a subset of get_choices(t_new).\n\nwhere one choicemap a is a \"subset\" of another choicemap b, when all keys that occur in a also occur in b, and the values at those addresses are equal. It is an error if no trace t_new satisfying the above conditions exists in the support of the model (with the new arguments).\n\nIf a deterministic trace transform is also provided, t_prop is transformed by a deterministic function before its choices are merged with t_old.\n\nBy default, a check is performed to ensure that no choices are  discarded as a result of updating the trace. Setting check = false allows for updates where previous observations are replaced with new ones.\n\n\n\n\n\n","category":"method"},{"location":"update/#Updating-with-custom-forward-and-backward-proposals","page":"Particle Updating","title":"Updating with custom forward and backward proposals","text":"","category":"section"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"pf_update!(\n    state::ParticleFilterView,\n    new_args::Tuple, argdiffs::Tuple,\n    observations::ChoiceMap,\n    fwd_proposal::GenerativeFunction, fwd_args::Tuple,\n    bwd_proposal::GenerativeFunction, bwd_args::Tuple,\n    transform::Union{TraceTransformDSLProgram,Nothing}\n)","category":"page"},{"location":"update/#GenParticleFilters.pf_update!-Tuple{ParticleFilterView{U} where U, Tuple, Tuple, Gen.ChoiceMap, Gen.GenerativeFunction, Tuple, Gen.GenerativeFunction, Tuple, Union{Nothing, Gen.TraceTransformDSLProgram}}","page":"Particle Updating","title":"GenParticleFilters.pf_update!","text":"pf_update!(state::ParticleFilterState, new_args::Tuple,\n           argdiffs::Tuple, observations::ChoiceMap,\n           fwd_proposal::GenerativeFunction, fwd_args::Tuple,\n           bwd_proposal::GenerativeFunction, bwd_args::Tuple,\n           [transform::TraceTransformDSLProgram];\n           check::Bool=false, prev_observations=EmptyChoiceMap())\n\nPerform a particle filter update, with a custom forward and backward kernel. New latent choices are sampled from fwd_proposal, and any discarded choices are evaluated under bwd_proposal. For each particle:\n\nfwd_proposal is evaluated with arguments (t_old, fwd_args...),  where t_old is the old model trace, and produces its own trace t_fwd.\nThe old model trace is replaced by a new model trace t_new, constructed by merging the choices in t_old and t_fwd, sampling any remaining choices from the model's default proposal, and discarding disc_choices, the choices in t_old inconsistent with those in t_fwd.\nThe probability of disc_choices is assessed under bwd_proposal with the arguments (t_new, bwd_args), giving a backward weight. This weight is used as a correction within the importance weight update, ensuring that the particle filter remains a valid approximation of the posterior.\n\nThe choicemap of t_new and disc_choices satisfy the following conditions:\n\nobservations is a subset of get_choices(t_new);\nget_choices(t_old) ∖ disc_choices is a subset of get_choices(t_new);\nget_choices(t_fwd) is a subset of get_choices(t_new).\ndisc_choices is  within the support of bwd_proposal\n\nFor valid posterior inference conditioned on prior observations, note that fwd_proposal should not cause any of those observations to be discarded, (i.e., disc_choices should not contain any observations given in previous calls to pf_update!).\n\nIf a trace transform is also provided, then more general forward and backward kernels can be used: t_new (the model's new trace) and t_bwd (the trace for the backward kernel) are constructed as a function of t_old, t_fwd, and any new observations. The check and prev_observations keyword arguments can also be set to true to check for correctness. (See UpdatingTraceTranslator for more details.)\n\nSimilar functionality is provided by move_reweight, except that pf_update! also allows model arguments to be updated.\n\n\n\n\n\n","category":"method"},{"location":"update/#Updating-with-a-trace-translator","page":"Particle Updating","title":"Updating with a trace translator","text":"","category":"section"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"Trace translators can be used to update particles in a highly general fashion, including the translation of traces from one generative function into traces of a different generative function.","category":"page"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"pf_update!(state::ParticleFilterView, translator)","category":"page"},{"location":"update/#GenParticleFilters.pf_update!-Tuple{ParticleFilterView{U} where U, Any}","page":"Particle Updating","title":"GenParticleFilters.pf_update!","text":"pf_update!(state::ParticleFilterState, translator; translator_args...)\n\nPerform a particle filter update using an arbitrary trace translator, which takes in each previous trace and returns a new trace and incremental log. importance weight. translator_args are additional keyword arguments which are passed to the translator when it is called.\n\n\n\n\n\n","category":"method"},{"location":"update/#Updating-with-stratified-sampling","page":"Particle Updating","title":"Updating with stratified sampling","text":"","category":"section"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"All of the above methods can also be combined with stratified sampling. This can be used to ensure deterministic coverage of the sample space of newly introduced random variables, thereby reducing variance.","category":"page"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"pf_update!(state::ParticleFilterView, new_args::Tuple, argdiffs::Tuple,\n           observations::ChoiceMap, strata)","category":"page"},{"location":"update/#GenParticleFilters.pf_update!-Tuple{ParticleFilterView{U} where U, Tuple, Tuple, Gen.ChoiceMap, Any}","page":"Particle Updating","title":"GenParticleFilters.pf_update!","text":"pf_update!(state::ParticleFilterState, new_args::Tuple,\n           argdiffs::Tuple, observations::ChoiceMap, strata,\n           [fwd_proposal::GenerativeFunction, fwd_args::Tuple,\n            bwd_proposal::GenerativeFunction, bwd_args::Tuple,\n            transform::TraceTransformDSLProgram];\n           layout=:interleaved, kwargs...)\n\npf_update!(state::ParticleFilterState, translator::TraceTranslator, strata;\n           layout=:interleaved, translator_args...)\n\nPerform a stratified particle filter update,  given a set of strata specified as an iterator over choicemaps. Each generated trace is constrained to both the provided observations and the choicemap for the stratum it belongs to. Forward proposals, backward proposals, trace transforms, or trace translators can also be specified, as in the non-stratified versions of pf_update!.\n\nFor a filter with N particles and K strata, each stratum is assigned at least B = ⌊N / K⌋ particles. If layout is :contiguous, these particles will be assigned in contiguous blocks (e.g., the particles for the first stratum will have indices 1:B). If layout is :interleaved, then  particles from each stratum will have interleaved indices (e.g., the first stratum will have indices 1:K:B*K). The remaining R particles are distributed at random among the strata, and allocated the indices N-R:N.\n\nBy default the layout is :interleaved, as this allows for convenient sub-stratification of the contiguous blocks allocated to each stratum when  performing stratified initialization with pf_initialize.\n\n\n\n\n\n","category":"method"},{"location":"update/","page":"Particle Updating","title":"Particle Updating","text":"For convenience, strata can be generated using the choiceproduct function.","category":"page"},{"location":"utils/#Data-Structures-and-Utilities","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"","category":"section"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"CurrentModule = GenParticleFilters","category":"page"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"The state of a particle filter is represented by a ParticleFilterState, which stores a set of traces (representing particles) and their associated (unnormalized) weights:","category":"page"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"ParticleFilterState","category":"page"},{"location":"utils/#Gen.ParticleFilterState","page":"Data Structures and Utilities","title":"Gen.ParticleFilterState","text":"ParticleFilterState\n\nA data structure that represents the current state of a particle filter.\n\n\n\n\n\n","category":"type"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"The following functions can be used to access the traces and weights:","category":"page"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"get_traces\nget_log_weights\nget_log_norm_weights\nget_norm_weights","category":"page"},{"location":"utils/#Gen.get_traces","page":"Data Structures and Utilities","title":"Gen.get_traces","text":"traces = get_traces(state::ParticleFilterState)\n\nReturn the vector of traces in the current state, one for each particle.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Gen.get_log_weights","page":"Data Structures and Utilities","title":"Gen.get_log_weights","text":"log_weights = get_log_weights(state::ParticleFilterState)\n\nReturn the vector of log weights for the current state, one for each particle.\n\nThe weights are not normalized, and are in log-space.\n\n\n\n\n\n","category":"function"},{"location":"utils/#GenParticleFilters.get_log_norm_weights","page":"Data Structures and Utilities","title":"GenParticleFilters.get_log_norm_weights","text":"get_log_norm_weights(state::ParticleFilterState)\n\nReturn the vector of normalized log weights for the current state, one for each particle.\n\n\n\n\n\n","category":"function"},{"location":"utils/#GenParticleFilters.get_norm_weights","page":"Data Structures and Utilities","title":"GenParticleFilters.get_norm_weights","text":"get_norm_weights(state::ParticleFilterState)\n\nReturn the vector of normalized weights for the current state, one for each particle.\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"Users can also sample traces from the particle filter, with probability proportional to their weights:","category":"page"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"sample_unweighted_traces","category":"page"},{"location":"utils/#Gen.sample_unweighted_traces","page":"Data Structures and Utilities","title":"Gen.sample_unweighted_traces","text":"traces::Vector = sample_unweighted_traces(state::ParticleFilterState, num_samples::Int)\n\nSample a vector of num_samples traces from the weighted collection of traces in the given particle filter state.\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"To enable parallelism and block-wise operations, users can index into a ParticleFilterState to obtain a ParticleFilterSubState:","category":"page"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"ParticleFilterSubState","category":"page"},{"location":"utils/#GenParticleFilters.ParticleFilterSubState","page":"Data Structures and Utilities","title":"GenParticleFilters.ParticleFilterSubState","text":"ParticleFilterSubState\n\nA data structure that represents a view into a subset of traces in a particle filter. If state is a ParticleFilterState, then state[idxs] or view(state, idxs) can be used to construct a ParticleFilterSubState which only contains the traces at the specified idxs.\n\n\n\n\n\n","category":"type"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"Aside from resizing, all particle filtering operations that can be applied to a ParticleFilterState can also be applied to a ParticleFilterSubState.","category":"page"},{"location":"utils/#Diagnostics","page":"Data Structures and Utilities","title":"Diagnostics","text":"","category":"section"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"Several functions are provided to compute particle filter diagnostics.","category":"page"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"effective_sample_size\nget_ess\nlog_ml_estimate\nget_lml_est","category":"page"},{"location":"utils/#Gen.effective_sample_size","page":"Data Structures and Utilities","title":"Gen.effective_sample_size","text":"effective_sample_size(state::ParticleFilterState)\n\nComputes the effective sample size of the particles in the filter.\n\n\n\n\n\n","category":"function"},{"location":"utils/#GenParticleFilters.get_ess","page":"Data Structures and Utilities","title":"GenParticleFilters.get_ess","text":"get_ess(state::ParticleFilterState)\n\nAlias for effective_sample_size. Computes the effective sample size.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Gen.log_ml_estimate","page":"Data Structures and Utilities","title":"Gen.log_ml_estimate","text":"estimate = log_ml_estimate(state::ParticleFilterState)\n\nReturn the particle filter's current estimate of the log marginal likelihood.\n\n\n\n\n\n","category":"function"},{"location":"utils/#GenParticleFilters.get_lml_est","page":"Data Structures and Utilities","title":"GenParticleFilters.get_lml_est","text":"get_lml_est(state::ParticleFilterState)\n\nAlias for log_ml_estimate. Returns the particle filter's current  estimate of the log marginal likelihood.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Statistics","page":"Data Structures and Utilities","title":"Statistics","text":"","category":"section"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"The following methods for computing summary statistics are also provided.","category":"page"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"mean(::ParticleFilterView, addr)\nmean(f::Function, ::ParticleFilterView, addr, addrs...)\nvar(::ParticleFilterView, addr)\nvar(f::Function, ::ParticleFilterView, addr, addrs...)\nproportionmap(::ParticleFilterView, addr)\nproportionmap(f::Function, ::ParticleFilterView, addr, addrs...)","category":"page"},{"location":"utils/#Statistics.mean-Tuple{ParticleFilterView{U} where U, Any}","page":"Data Structures and Utilities","title":"Statistics.mean","text":"mean(state::ParticleFilterState[, addr])\n\nReturns the weighted empirical mean for a particular trace address addr. If addr is not provided, returns the empirical mean of the return value associated with each trace in the particle filter.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Statistics.mean-Tuple{Function, ParticleFilterView{U} where U, Any, Vararg{Any, N} where N}","page":"Data Structures and Utilities","title":"Statistics.mean","text":"mean(f::Function, state::ParticleFilterState[, addrs...])\n\nReturns the weighted empirical mean of a function f applied to the values at one or more trace addresses addrs, where f takes in a number of arguments equal to the number of addresses.\n\nIf no addresses are provided, f is applied to the return value of each trace.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Statistics.var-Tuple{ParticleFilterView{U} where U, Any}","page":"Data Structures and Utilities","title":"Statistics.var","text":"var(state::ParticleFilterState[, addr])\n\nReturns the empirical variance for a particular trace address addr. If addr is not provided, returns the empirical variance of the return value associated with each trace in the particle filter.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Statistics.var-Tuple{Function, ParticleFilterView{U} where U, Any, Vararg{Any, N} where N}","page":"Data Structures and Utilities","title":"Statistics.var","text":"var(f::Function, state::ParticleFilterState[, addrs...])\n\nReturns the empirical variance of a function f applied to the values at one or more trace addresses addrs, where f takes in a number of arguments equal to the number of addresses.\n\nIf no addresses are provided, f is applied to the return value of each trace.\n\n\n\n\n\n","category":"method"},{"location":"utils/#StatsBase.proportionmap-Tuple{ParticleFilterView{U} where U, Any}","page":"Data Structures and Utilities","title":"StatsBase.proportionmap","text":"proportionmap(state::ParticleFilterState[, addr])\n\nReturns a dictionary mapping each unique value at a trace address addr to its proportion (i.e. sum of normalized weights) in the particle filter. If addr is not provided, returns the proportions of each possible return value.\n\n\n\n\n\n","category":"method"},{"location":"utils/#StatsBase.proportionmap-Tuple{Function, ParticleFilterView{U} where U, Any, Vararg{Any, N} where N}","page":"Data Structures and Utilities","title":"StatsBase.proportionmap","text":"proportionmap(f::Function, state::ParticleFilterState[, addrs...])\n\nApplies f to the values at one or more trace addresses addrs, then returns a dictionary mapping each unique value to its proportion (i.e. sum of normalized weights) in the particle filter. \n\nIf no addresses are provided, f is applied to the return value of each trace.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Stratification","page":"Data Structures and Utilities","title":"Stratification","text":"","category":"section"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"To support the use of stratified sampling, the choiceproduct method can be used to conveniently generate a list of choicemap strata:","category":"page"},{"location":"utils/","page":"Data Structures and Utilities","title":"Data Structures and Utilities","text":"choiceproduct","category":"page"},{"location":"utils/#GenParticleFilters.choiceproduct","page":"Data Structures and Utilities","title":"GenParticleFilters.choiceproduct","text":"choiceproduct((addr, vals))\nchoiceproduct((addr, vals), choices::Tuple...)\nchoiceproduct(choices::Dict)\n\nReturns an iterator over ChoiceMaps given a tuple or sequence of tuples of the form  (addr, vals), where addr specifies a choice address, and vals specifies a list of values for that address.\n\nIf multiple tuples are provided, the iterator will be a Cartesian product over the (addr, vals) pairs, where each resulting ChoiceMap contains all specified addresses. Instead of specifying multiple tuples, a dictionary mapping addresses to values can also be provided.\n\nExamples\n\nThis function can be used to conveniently generate ChoiceMaps for stratified sampling. For example, we can use choiceproduct instead of manually constructing a list of strata:\n\n# Manual construction\nstrata = [choicemap((:a,  1), (:b,  3)), choicemap((:a,  2), (:b,  3))]\n# Using choiceproduct\nstrata = choiceproduct((:a, [1, 2]), (:b, [3]))\n\n\n\n\n\n","category":"function"},{"location":"resample/#Particle-Resampling","page":"Particle Resampling","title":"Particle Resampling","text":"","category":"section"},{"location":"resample/","page":"Particle Resampling","title":"Particle Resampling","text":"CurrentModule = GenParticleFilters","category":"page"},{"location":"resample/","page":"Particle Resampling","title":"Particle Resampling","text":"Several different resampling methods are supported by GenParticleFilters.jl,  each with their own variance properties.","category":"page"},{"location":"resample/","page":"Particle Resampling","title":"Particle Resampling","text":"pf_resample!","category":"page"},{"location":"resample/#GenParticleFilters.pf_resample!","page":"Particle Resampling","title":"GenParticleFilters.pf_resample!","text":"pf_resample!(state::ParticleFilterState, method=:multinomial; kwargs...)\n\nResamples particles in the filter, stochastically pruning low-weight particles. The resampling method can optionally be specified: :multinomial (default), :residual, or :stratified. See [1] for a survey of resampling methods and their variance properties.\n\nA priority_fn can also be specified as a keyword argument, which maps log particle weights to custom log priority scores for the purpose of resampling (e.g. w -> w/2 for less aggressive pruning).\n\n[1] R. Douc and O. Cappé, \"Comparison of resampling schemes for particle filtering,\" in ISPA 2005. Proceedings of the 4th International Symposium on Image and Signal Processing and Analysis, 2005., 2005, pp. 64–69.\n\n\n\n\n\n","category":"function"},{"location":"resample/#Multinomial-resampling","page":"Particle Resampling","title":"Multinomial resampling","text":"","category":"section"},{"location":"resample/","page":"Particle Resampling","title":"Particle Resampling","text":"pf_multinomial_resample!","category":"page"},{"location":"resample/#GenParticleFilters.pf_multinomial_resample!","page":"Particle Resampling","title":"GenParticleFilters.pf_multinomial_resample!","text":"pf_multinomial_resample!(state::ParticleFilterState; kwargs...)\n\nPerforms multinomial resampling (i.e. simple random resampling) of the particles in the filter. Each trace (i.e. particle) is resampled with probability proportional to its weight.\n\nA priority_fn can be specified as a keyword argument, which maps log particle weights to custom log priority scores for the purpose of resampling (e.g. w -> w/2 for less aggressive pruning).\n\n\n\n\n\n","category":"function"},{"location":"resample/#Residual-resampling","page":"Particle Resampling","title":"Residual resampling","text":"","category":"section"},{"location":"resample/","page":"Particle Resampling","title":"Particle Resampling","text":"pf_residual_resample!","category":"page"},{"location":"resample/#GenParticleFilters.pf_residual_resample!","page":"Particle Resampling","title":"GenParticleFilters.pf_residual_resample!","text":"pf_residual_resample!(state::ParticleFilterState; kwargs...)\n\nPerforms residual resampling of the particles in the filter, which reduces variance relative to multinomial sampling. For each particle with normalized weight w_i, n w_i copies are resampled, where n is the total number of particles. The remainder are sampled with probability proportional to n w_i - n w_i for each particle i.\n\nA priority_fn can be specified as a keyword argument, which maps log particle weights to custom log priority scores for the purpose of resampling (e.g. w -> w/2 for less aggressive pruning).\n\n\n\n\n\n","category":"function"},{"location":"resample/#Stratified-resampling","page":"Particle Resampling","title":"Stratified resampling","text":"","category":"section"},{"location":"resample/","page":"Particle Resampling","title":"Particle Resampling","text":"pf_stratified_resample!","category":"page"},{"location":"resample/#GenParticleFilters.pf_stratified_resample!","page":"Particle Resampling","title":"GenParticleFilters.pf_stratified_resample!","text":"pf_stratified_resample!(state::ParticleFilterState; kwargs...)\n\nPerforms stratified resampling of the particles in the filter, which reduces variance relative to multinomial sampling. First, uniform random samples u_1  u_n are drawn within the strata 0 1n), ..., n-1n 1), where n is the number of particles. Then, given the cumulative normalized weights W_k = Σ_j=1^k w_j, sample the kth particle for each u_i where W_k-1  u_i  W_k.\n\nA priority_fn can be specified as a keyword argument, which maps log particle weights to custom log priority scores for the purpose of resampling (e.g. w -> w/2 for less aggressive pruning). The sort_particles keyword argument controls whether particles are sorted by weight before stratification (default: true).\n\n\n\n\n\n","category":"function"},{"location":"#GenParticleFilters.jl","page":"Home","title":"GenParticleFilters.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A library for simple and advanced particle filtering in Gen, a general-purpose probabilistic programming system.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Press ] at the Julia REPL to enter the package manager, then run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add GenParticleFilters","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the development version, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/probcomp/GenParticleFilters.jl.git","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In addition to basic particle filtering functionality (i.e., initializing a particle filter and updating it with new observations), this package provides support for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Particle updates that allow discarding of old choices, provided that backward kernels are specified [1]\nMultiple resampling methods, including variance-reducing methods such as residual resampling [2]\nCustom priority weights for resampling, to control the aggressiveness of pruning [3]\nMetropolis-Hasting (i.e. move-accept) rejuvenation moves, to increase particle diversity [4]\nMove-reweight rejuvenation, which increases particle diversity while reweighting particles [5]\nSequential Monte Carlo over a series of distinct models, via trace translators [6]\nSMCP³, a method which generalizes [1], [5] and [6] through particle updates that support auxiliary randomness and deterministic transformations  [7]\nParticle filter resizing methods, which can be used in online adaptation of the total number of particles [8]\nUtility functions to compute distributional statistics (e.g. mean and variance) for the inferred latent variables","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Suppose we are trying to infer the position y of an object that is either staying still or moving sinusoidally, given noisy measurements y_obs. We can write a model of this object's motion as an @gen function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@gen function object_motion(T::Int)\n    y, moving = 0, false\n    y_obs_all = Float64[]\n    for t=1:T\n        moving = {t => :moving} ~ bernoulli(moving ? 0.75 : 0.25)\n        vel_y = moving ? sin(t) : 0.0\n        y = {t => :y} ~ normal(y + vel_y, 0.01)\n        y_obs = {t => :y_obs} ~ normal(y, 0.25)\n        push!(y_obs_all, y_obs)\n    end\n    return y_obs_all\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then construct a particle filter with resampling and rejuvenation moves, in order to infer both the object's position y and whether the object was moving at each timestep.","category":"page"},{"location":"","page":"Home","title":"Home","text":"function particle_filter(observations, n_particles, ess_thresh=0.5)\n    # Initialize particle filter with first observation\n    n_obs = length(observations)\n    obs_choices = [choicemap((t => :y_obs, observations[t])) for t=1:n_obs]\n    state = pf_initialize(object_motion, (1,), obs_choices[1], n_particles)\n    # Iterate across timesteps\n    for t=2:n_obs\n        # Resample and rejuvenate if the effective sample size is too low\n        if effective_sample_size(state) < ess_thresh * n_particles\n            # Perform residual resampling, pruning low-weight particles\n            pf_resample!(state, :residual)\n            # Perform a rejuvenation move on past choices\n            rejuv_sel = select(t-1=>:moving, t-1=>:y, t=>:moving, t=>:y)\n            pf_rejuvenate!(state, mh, (rejuv_sel,))\n        end\n        # Update filter state with new observation at timestep t\n        pf_update!(state, (t,), (UnknownChange(),), obs_choices[t])\n    end\n    return state\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then run the particle filter on a sequence of observations, e.g., of the object staying still for 5 timesteps then oscillating for 5 timesteps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Generate synthetic dataset of object motion\nconstraints = choicemap([(t => :moving, t > 5) for t in 1:10]...)\ntrace, _ = generate(object_motion, (10,), constraints)\nobservations = get_retval(trace)\n# Run particle filter with 100 particles\nstate = particle_filter(observations, 100)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then use mean and var to compute the empirical posterior mean and variance for variables of interest:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> mean(state, 5=>:moving) |> x->round(x, digits=2) # Prob. motion at t=5\n0.07\njulia> var(state, 5=>:moving) |> x->round(x, digits=2) # Variance at t=5\n0.07\njulia> mean(state, 6=>:moving) |> x->round(x, digits=2) # Prob. motion at t=6\n0.95\njulia> var(state, 6=>:moving) |> x->round(x, digits=2) # Variance at t=6\n0.05","category":"page"},{"location":"","page":"Home","title":"Home","text":"We see that the filter accurately infers a change in motion from t=5 to t=6.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p>\n<a id=\"1\">[1]</a> P. D. Moral, A. Doucet, and A. Jasra, \"Sequential Monte Carlo samplers,\" Journal of the Royal Statistical Society: Series B (Statistical Methodology), vol. 68, no. 3, pp. 411–436, 2006.\n</p>\n<p>\n<a id=\"2\">[2]</a> R. Douc and O. Cappé, \"Comparison of resampling schemes for particle filtering,\" in ISPA 2005. Proceedings of the 4th International Symposium on Image and Signal Processing and Analysis, 2005., 2005, pp. 64-69.\n</p>\n<p>\n<a id=\"3\">[3]</a> R. Chen, \"Sequential Monte Carlo methods and their applications,\" in Markov Chain Monte Carlo, vol. Volume 7, 0 vols., Singapore University Press, 2005, pp. 147–182.\n</p>\n<p>\n<a id=\"4\">[4]</a> N. Chopin, “A sequential particle filter method for static models,” Biometrika 89.3, 2000, pp. 539-552.\n</p>\n<p>\n<a id=\"5\">[5]</a> R. A. G. Marques and G. Storvik, \"Particle move-reweighting strategies for online inference,\" Preprint series. Statistical Research Report, 2013.\n</p>\n<p>\n<a id=\"6\">[6]</a> M. Cusumano-Towner, B. Bichsel, T. Gehr, M. Vechev, and V. K. Mansinghka, “Incremental inference for probabilistic programs,” in Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation, Philadelphia PA USA, Jun. 2018, pp. 571–585.\n</p>\n<p>\n<a id=\"7\">[7]</a> Lew, A. K., Matheos, G., Zhi-Xuan, T., Ghavamizadeh, M., Gothoskar, N., Russell, S., and Mansinghka, V. K. \"SMCP3: Sequential Monte Carlo with Probabilistic Program Proposals.\" AISTATS, 2023.\n</p>\n<p>\n<a id=\"8\">[8]</a> V. Elvira, J. Míguez and P. M. Djurić, \"Adapting the Number of Particles in Sequential Monte Carlo Methods Through an Online Scheme for Convergence Assessment,\" in IEEE Transactions on Signal Processing, vol. 65, no. 7, pp. 1781-1794, 1 April 2017, doi: 10.1109/TSP.2016.2637324.\n</p>","category":"page"},{"location":"initialize/#Particle-Initialization","page":"Particle Initialization","title":"Particle Initialization","text":"","category":"section"},{"location":"initialize/","page":"Particle Initialization","title":"Particle Initialization","text":"CurrentModule = GenParticleFilters","category":"page"},{"location":"initialize/","page":"Particle Initialization","title":"Particle Initialization","text":"To initialize a particle filter, GenParticleFilters.jl supports both regular initialization via simple random sampling and stratified initialization.","category":"page"},{"location":"initialize/#Random-initialization","page":"Particle Initialization","title":"Random initialization","text":"","category":"section"},{"location":"initialize/","page":"Particle Initialization","title":"Particle Initialization","text":"By default, particles are sampled randomly according to the internal proposal of the provided model, or a custem proposal if one is specified.","category":"page"},{"location":"initialize/","page":"Particle Initialization","title":"Particle Initialization","text":"pf_initialize(model::GenerativeFunction, model_args::Tuple,\n              observations::ChoiceMap, n_particles::Int)","category":"page"},{"location":"initialize/#GenParticleFilters.pf_initialize-Tuple{Gen.GenerativeFunction, Tuple, Gen.ChoiceMap, Int64}","page":"Particle Initialization","title":"GenParticleFilters.pf_initialize","text":"pf_initialize(model::GenerativeFunction, model_args::Tuple,\n              observations::ChoiceMap, n_particles::Int;\n              dynamic=false)\n\npf_initialize(model::GenerativeFunction, model_args::Tuple,\n              observations::ChoiceMap, proposal::GenerativeFunction,\n              proposal_args::Tuple, n_particles::Int;\n              dynamic=false)\n\nInitialize a particle filter, generating traces (i.e. particles) from the model constrained to the provided observations. A custom proposal can optionally be used to propose choices for the initial set of traces. Returns a ParticleFilterState.\n\nIf dynamic is true, the particle filter will not be specialized to a fixed trace type, allowing for sequential Monte Carlo inference over a sequence of models with differing structure, at the expense of more memory usage.\n\n\n\n\n\n","category":"method"},{"location":"initialize/#Stratified-initialization","page":"Particle Initialization","title":"Stratified initialization","text":"","category":"section"},{"location":"initialize/","page":"Particle Initialization","title":"Particle Initialization","text":"To reduce variance, particle filters can also be initialized via stratified sampling, given a list of provided strata.","category":"page"},{"location":"initialize/","page":"Particle Initialization","title":"Particle Initialization","text":"pf_initialize(model::GenerativeFunction, model_args::Tuple,\n              observations::ChoiceMap, strata, n_particles::Int)","category":"page"},{"location":"initialize/#GenParticleFilters.pf_initialize-Tuple{Gen.GenerativeFunction, Tuple, Gen.ChoiceMap, Any, Int64}","page":"Particle Initialization","title":"GenParticleFilters.pf_initialize","text":"pf_initialize(model::GenerativeFunction, model_args::Tuple, \n              observations::ChoiceMap, strata, n_particles::Int;\n              layout=:contiguous, dynamic=false)\n\npf_initialize(model::GenerativeFunction, model_args::Tuple,\n              observations::ChoiceMap, strata,\n              proposal::GenerativeFunction, proposal_args::Tuple,\n              n_particles::Int; layout=:contiguous, dynamic=false)\n\nPerform stratified initialization of a particle filter, given a set of strata specified as an iterator over choicemaps. Each generated trace is constrained to both the provided observations and the choicemap for the stratum it belongs to. A custom proposal can optionally be used to propose unconstrained choices.\n\nFor a filter with N particles and K strata, each stratum is first allocated B = ⌊N / K⌋ particles. If layout is :contiguous, these particles will be allocated in contiguous blocks (e.g., the particles for the first stratum will have indices 1:B). If layout is :interleaved, then  particles from each stratum will have interleaved indices (e.g., the first stratum will have indices 1:K:B*K). The remaining R particles are distributed at random among the strata, and allocated the indices N-R:N.\n\nIf dynamic is true, the particle filter will not be specialized to a fixed trace type, allowing for sequential Monte Carlo inference over a sequence of models with differing structure, at the expense of more memory usage.\n\n\n\n\n\n","category":"method"},{"location":"initialize/","page":"Particle Initialization","title":"Particle Initialization","text":"For convenience, strata can be generated using the choiceproduct function.","category":"page"},{"location":"rejuvenate/#Particle-Rejuvenation","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"","category":"section"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"CurrentModule = GenParticleFilters","category":"page"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"To increase particle diversity (e.g. after a resampling step), GenParticleFilters.jl provides support for both MCMC and move-reweight rejuvenation kernels.","category":"page"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"pf_rejuvenate!","category":"page"},{"location":"rejuvenate/#GenParticleFilters.pf_rejuvenate!","page":"Particle Rejuvenation","title":"GenParticleFilters.pf_rejuvenate!","text":"pf_rejuvenate!(state::ParticleFilterState, kern, kern_args::Tuple=(),\n               n_iters::Int=1; method=:move, kwargs...)\n\nRejuvenates particles by repeated application of a kernel kern. kern should be a callable which takes a trace as its first argument, and returns a tuple with a trace as the first return value. method specifies the rejuvenation method: :move for MCMC moves without a reweighting step, and :reweight for rejuvenation with a reweighting step. Additional keyword arguments are passed to the kernel.\n\n\n\n\n\n","category":"function"},{"location":"rejuvenate/#MCMC-rejuvenation","page":"Particle Rejuvenation","title":"MCMC rejuvenation","text":"","category":"section"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"MCMC rejuvenation can be used to diversify the set of existing particles by applying an invariant MCMC kernel (e.g. a Metropolis-Hastings kernel) to each particle. Since the kernel is expected to be invariant, kernel application does not adjust the particle weights.","category":"page"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"pf_move_accept!","category":"page"},{"location":"rejuvenate/#GenParticleFilters.pf_move_accept!","page":"Particle Rejuvenation","title":"GenParticleFilters.pf_move_accept!","text":"pf_move_accept!(state::ParticleFilterState, kern,\n                kern_args::Tuple=(), n_iters::Int=1; kwargs...)\n\nRejuvenates particles by repeated application of a MCMC kernel kern. kern should be a callable which takes a trace as its first argument, and returns a tuple (trace, accept), where trace is the (potentially) new trace, and accept is true if the MCMC move was accepted. Subsequent arguments to kern can be supplied with kern_args or kwargs. The kernel is repeatedly applied to each trace for n_iters.\n\n\n\n\n\n","category":"function"},{"location":"rejuvenate/#Move-reweight-rejuvenation","page":"Particle Rejuvenation","title":"Move-reweight rejuvenation","text":"","category":"section"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"Move-reweight rejuvenation can be used to simultaneously diversify the set of existing particles while updating their weights.","category":"page"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"pf_move_reweight!","category":"page"},{"location":"rejuvenate/#GenParticleFilters.pf_move_reweight!","page":"Particle Rejuvenation","title":"GenParticleFilters.pf_move_reweight!","text":"pf_move_reweight!(state::ParticleFilterState, kern,\n                  kern_args::Tuple=(), n_iters::Int=1; kwargs...)\n\nRejuvenates and reweights particles by repeated application of a reweighting kernel kern, as described in [1]. kern should be a callable which takes a trace as its first argument, and returns a tuple (trace, rel_weight), where trace is the new trace, and rel_weight is the relative log-importance weight. Subsequent arguments to kern can be supplied with kern_args or kwargs. The kernel is repeatedly applied to each trace for n_iters, and the weights accumulated accordingly.\n\nBoth the move_reweight function and symmetric trace translators can serve as reweighting kernels. \n\n[1] R. A. G. Marques and G. Storvik, \"Particle move-reweighting strategies for online inference,\" Preprint series. Statistical Research Report, 2013.\n\n\n\n\n\n","category":"function"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"To define a move-reweight kernel, the following methods are provided:","category":"page"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"move_reweight","category":"page"},{"location":"rejuvenate/#GenParticleFilters.move_reweight","page":"Particle Rejuvenation","title":"GenParticleFilters.move_reweight","text":"move_reweight(trace, selection; kwargs...)\nmove_reweight(trace, proposal, proposal_args; kwargs...)\nmove_reweight(trace, proposal, proposal_args, involution; kwargs...)\nmove_reweight(trace, proposal_fwd, args_fwd, proposal_bwd, args_bwd,\n              involution ; kwargs...)\n\nMove-reweight rejuvenation kernel, which takes in a trace and returns a new trace along with a relative importance weight. This can be used for rejuvenation within a particle filter, as described in [1].\n\nSeveral variants of move_reweight exist, differing in the complexity involved in proposing and re-weighting random choices:\n\nThe selection variant regenerates the addresses specified by selection using the model's default proposal.\nA proposal generative function and arguments can be provided, to propose new random choices using a custom proposal distribution. proposal must take the original trace as its first input argument.\nAn involution can also be provided, to handle more complex proposal distributions which add/remove trace addresses.\nSeparate forward and backward proposal distributions, proposal_fwd and proposal_bwd, can be provided, as long they share the same support. This adjusts the computation of the relative importance weight by scoring the backward choices under the backward proposal.\n\nSimilar to metropolis_hastings, a check flag and observations choicemap can be provided as keyword arguments to ensure that observed choices are preserved in the new trace.\n\n[1] R. A. G. Marques and G. Storvik, \"Particle move-reweighting strategies for online inference,\" Preprint series. Statistical Research Report, 2013.\n\n\n\n\n\n","category":"function"},{"location":"rejuvenate/","page":"Particle Rejuvenation","title":"Particle Rejuvenation","text":"Care must be taken in choosing forward and backward kernels to reduce variance in the weight updates. A helpful rule-of-thumb when specifying backward kernels is to try and make them locally optimal: If pi(x) is the initial distribution of particles prior to the rejuvenation move, and K(x x) is the forward kernel that will be applied to perturb each particle, then the backward kernel L(x x) should be designed to approximate the local posterior P(x  x) propto pi(x) K(x x).","category":"page"}]
}
